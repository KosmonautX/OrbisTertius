# Phos Phoenix Runtime Node

## Root

```elixir
req = "5c82aeea-7c2b-4a97-a80b-d5b728c4ee86"
acpt = "9bf9c443-f89b-460a-972d-6704ae66823d"
alt = "deb2800c-a418-40fe-b35a-db30b01f59f8"
import Ecto.Query
alias Phos.Users.{RelationBranch, RelationRoot, User}

## CREATE
payload = %{
  "initiator_id" => req,
  "acceptor_id" => acpt,
  "branches" => [
    %{"user_id" => acpt, "friend_id" => req},
    %{"user_id" => req, "friend_id" => acpt}
  ]
}

%RelationRoot{}
|> RelationRoot.gen_branches_changeset(payload)
|> Phos.Repo.insert()

# ## READ

# Phos.Repo.get_by(RelationBranch, [user_id: req, friend_id: acpt])
# |> Phos.Repo.preload(:root)

# ## UPDATE
# payloadz = %{"state" => "completed"}
# Phos.Repo.get!(RelationRoot, "5a096428-32b9-45a9-b5c1-a6f68443d201")
# |> RelationRoot.mutate_state_changeset(payloadz)
# |> Phos.Repo.update()

# Phos.Repo.one(from u in User,
#       where: u.id == ^req,
#       left_join: rel in subquery(from r in RelationBranch,
#         where: r.friend_id == ^acpt,
#         inner_join: root in assoc(r, :root),
#         select: root
#       ),
#       select_merge: %{self_relation: rel}
#     ) 
#     |> Phos.Repo.Preloader.lateral(:orbs, [limit: 5])

from(l in Phos.Action.Orb_Location,
  as: :l,
  where: l.location_id in ^[623_276_216_935_972_863 |> :h3.parent(8)],
  left_join: orbs in assoc(l, :orbs),
  on: orbs.userbound != true,
  left_join: initiator in assoc(orbs, :initiator),
  select: orbs,
  left_join:
    rel in subquery(
      from(r in Phos.Users.RelationBranch,
        where: r.friend_id == ^req,
        inner_join: root in assoc(r, :root),
        select: root
      )
    ),
  select_merge: %{initiator: %{initiator | self_relation: rel}},
  inner_lateral_join:
    c in subquery(
      from(c in Phos.Comments.Comment,
        where: c.orb_id == parent_as(:l).orb_id,
        select: %{count: count()}
      )
    ),
  select_merge: %{comment_count: c.count}
)
|> Phos.Repo.all()
```

```elixir

```

```elixir
defmodule R do
  def recompile() do
    Mix.Task.reenable("app.start")
    Mix.Task.reenable("compile")
    Mix.Task.reenable("compile.all")
    compilers = Mix.compilers()
    Enum.each(compilers, &Mix.Task.reenable("compile.#{&1}"))
    Mix.Task.run("compile.all")
  end
end

R.recompile()
```

<!-- livebook:{"branch_parent_index":0} -->

## External APIs

```elixir
token = "secret_iEEKNgkL0gE0Havl8c840X0rSrUXlQf5xrKEXDzRqxb"
database = "6651c1b694844da39faa51d019fe6baf"

# headers = [
#   Authorization: "Bearer #{token}",
#   "Content-Type": "application/json",
#   "Notion-Version": "2022-02-22"
# ]

today = DateTime.utc_now() |> DateTime.add(60 * 60 * 10) |> DateTime.to_date()

date_query = %{
  "filter" => %{
    "property" => "Posting date",
    "date" => %{
      "equals" => today
    }
  }
}

today_post = Phos.External.Notion.post!("/databases/" <> database <> "/query", date_query, [])
```

<!-- livebook:{"branch_parent_index":0} -->

## oRBs

```elixir
Phos.Action.get_orbs_by_geohashes([614_269_017_680_510_975])
|> PhosWeb.Util.Viewer.fresh_orb_stream_mapper()
```

<!-- livebook:{"branch_parent_index":0} -->

## Users

```elixir
user_id = List.first(Phos.Users.list_users()).id

{:ok, orb} =
  Phos.Action.create_orb_and_publish(%{
    "id" => Ecto.UUID.generate(),
    "active" => true,
    "extinguish" => ~N[2022-05-20 12:12:00],
    "media" => true,
    "title" => "weird",
    "initiator_id" => user_id,
    "geolocation" => [623_276_216_929_910_783],
    "payload" => %{"where" => "here"}
  })

orb
```
